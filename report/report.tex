\documentclass[danish]{article}

\usepackage{fullpage} 
\usepackage[latin1]{inputenc} 
\usepackage[danish]{babel}
\usepackage{listings} 
\usepackage{xcolor}
\usepackage{amssymb} 
\usepackage{amsmath} 
\usepackage{fancyhdr}
\usepackage{lastpage} 
\usepackage{hyperref}
\usepackage{parskip} 
\usepackage{graphicx} 
\usepackage{epstopdf}
\usepackage{abstract}


% setup c sharp syntax highlight 
\lstdefinestyle{sharpc}{ language=[Sharp]C,
frame=lr, rulecolor=\color{black}, basicstyle=\footnotesize\ttfamily,
keywordstyle=\bfseries\color{green!40!black},
commentstyle=\itshape\color{purple!40!black}, identifierstyle=\color{blue},
stringstyle=\color{orange}}

\lstset{ style=sharpc, numbers=left, escapeinside={\<*}{*>},
breakatwhitespace=true }

% code formatting helper 
\newcommand{\code}[1]{\texttt{#1}}

% no paragraph indention 
\setlength{\parindent}{0pt}

% setup page style 
\pagestyle{fancy} 
\fancyhf{} 
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt} 
\lfoot{Side \thepage{} af \pageref{LastPage}}
\rfoot{07/05-2013} \lhead{02180 Intro to A.I.} 
\chead{Heureka} 
\rhead{}

\author{
  Patrick Gadd\\
  \texttt{s113491}
  \and
  Simon Altschuler\\
  \texttt{s123563}
}
\title{Heureka projekt}
\date{07/05-2013}

\begin{document}
\maketitle

\textbf{Abstract} \\ 
I denne opgave gennemgås hvordan deduktion i sætningslogik (eng: Propositional Logic) samt rutefinding kan optimeres ved at repræsentere disse som grafer.
Når denne type problemer er repræsenteret som grafer, er det muligt at anvende \code{A*}-algoritmen, med en passende heuristisk funktion, til at finde en løsning mere effektivt end ved eksempelvis Breadth-First-Search (BFS) eller Uniform-Cost-Search (UCS).
I opgaven vil teorien bag samt implementationen blive gennemgået.

\clearpage

\section{Introduktion} 

Til projektet har vi brugt \code{C\#} til implementation af programmet. 

\section{\code{A*} generelt} 
\code{A*}-algoritmen bruges generelt til at søge mere effektivt i grafer, end \code{BFS} og \code{UCS}, som den tager udgangspunkt i.
Algoritmen forudsætter dog at der er tale om informeret søgning, hvilket betyder at man fra en vilkårlig knude kan estimere hvor langt man er fra mål-knuden i søgningen, samt at der holdes styr på hvor dybt den givne knude ligger i søgetræet.

\code{BFS} prioriterer at man udforsker knuder, sådan at dybden af grenene i søgetræet maksimalt er dybden én fra hinanden.
Dette opnås ved at lægge knuderne i en \code{FIFO-kø}.

\code{UCS} bygger videre på \code{BFS}, men introducerer en cost-funktion, \code{g(n)}, som anvender vægtning af kanterne mellem knuder til at holde søgegrenenes længde uniform.
\code{g(n)} er summen af kantlængderne fra rodknuden til den nuværende.
\code{FIFO-køen} udskiftes med en prioritetskø, der netop bruger \code{g(n)} til at afgøre hvilken knude der skal udforskes som den næste.

\code{A*} er en videreudvikling af \code{UCS}, der anvender en heuristisk-funktion, \code{h(n)}, som forsøger at forudsige hvor langt der højst er til mål-knuden fra en given knude.
Ved at tage summen af \code{g(n)} og \code{h(n)} har man et optimistisk estimat for den totale længde af den korteste rute fra en knude i prioritetskøen, \code{f(n)}.
Hermed forsøger algoritmen direkte at følge den korteste rute til mål-knuden.

Når algoritmen udforsker en knude, vil det i kraft af \code{f(n)}, være den på den korteste rute til mål-knuden gennem den givne knude.
Dette medfører at når en knude én gang har været udforsket, skal andre ruter/grene af søgningen ikke efterfølgende udforske ruter hvori den indgår, da disse vil have større \code{f(n)} i sidste ende.

\subsection{Cost-funktion og Heurestik}

\subsection{Implementering af algoritmen}
\begin{lstlisting}
SearchResult Search(Node initialNode, KnowledgeBase kb)
{ 	frontier = new PriorityQueue<NodeAbstract>();
   explored = new List<StateAbstract>();
   end = initialNode.Target;  //StateAbstract
   frontier.Add(initialNode);
    
   while (frontier.Count > 0){
      currentNode = frontier.Pop(); // Chooses the lowest-cost node in the frontier
	  if (currentNode.State.Equals(end))
	     return new SearchResult(currentNode, statesSearched, true); //Return if goal-state is reached
		
        explored.Add(currentNode.State);
        
        var actions = kb.ActionsForNode(currentNode); //Get available actions to the State of the current Node

		foreach (var action in actions)
         {
			var child = kb.Resolve(currentNode, action, end, explored);
			if (!explored.Contains(child.State))
            {
				explored.Add(child.State);
				frontier.Add(child);
            }else{
				//Giver mening hvis man ser eksemplet i bogen s. 84.
				for (int i = 0; i < frontier.Count; i++)
				{
					var frontierNode = frontier[i];
					if (frontierNode.State.Equals(child.State) && frontierNode.PathCost > child.PathCost)
					{
						frontier[i] = child;
						break;
					}
				}
			}
        }
    }
    return new SearchResult(null, statesSearched, false);
}

\end{lstlisting}



\section{Rutefinding} 
I rutefinding har vi implementeret \code{A*} algoritmen med formålet at finde korteste vej i en vægtet graf, som repræsenterer faktiske kort over landområder. Vi har testet vores implementation med de fra undervisningen givne kort over dele af København og Manhattan.

\subsection{Repræsentation af data / Datastrukturer}
I rutefinding består et \code{State} af et \code{(X,Y)} koordinat som beskriver knudens position på kortet. Dette er alt hvad der skal bruges for at udregne den heuristiske værdi fra en arbitrær knude til en given mål-\code{State}.

En \code{Action} finder sin cost ved at udregne afstanden mellem sit \code{StartState} og \code{EndState}s koordinater.

Knowledge basen for rutefinding genereres ud fra en tekstfil med følgende struktur:

\begin{lstlisting}
startX_1 startY_1 navn_1 slutX_1 slutY_1
startX_2 startY_2 navn_2 slutX_2 slutY_2
...
startX_n startY_n navn_n slutX_n slutY_n
\end{lstlisting}

Dette bliver parset til to states (start og end) og en action i mellem dem, som alle bliver gemt i Knowledge basen. Alle \code{Action}s bliver fundet på forhånd så \code{A*} algoritmen ikke skal søge gennem \code{State}s under eksekvering, men blot kan slå de relevante \code{Action}s op. Det betyder et større pladsforbrug, men en bedre tidskompleksitet efter parsing.

Hver linie i knowledge basen repræsenterer en \emph{ensrettet} vej, hvilket vil sige at der skal to linier til at beskrive en vej på hvilken man både kan gå den ene og den anden vej.

\subsection{Heuristik}
Den heuristiske værdi for en \code{Node} (\code{h(node)}) i rutefinding er bestemt ud fra fugleflugts afstanden til målet. Den strategi egner sig bedst til åbne grafer uden ``blindgyder'', da \code{h(node)} ikke kan tage højde for disse og vil forsøge at gå ned af blindgyderne hvis de ligger tættere på målet. \code{f(node)}, altså den samlede heuristiske værdi (cost indtil nu plus estimeret afstand til mål), udregnes på følgende måde for enhver knude i grafen under rutefinding:
\[ h(node) = \sqrt{(node.State.X - targetState.X)^2 + (node.State.Y - targetState.Y)^2} \]
\[ f(node) = node.Parent.PathCost + node.Action.Cost + h(node) \]
Hvor \code{node.Parent} er den \code{Node} fra hvilken algoritmen kom til den nuværende \code{Node}. \code{node.PathCost} er den samlede cost for at komme til \code{Node}n, \emph{uden} den heuristiske værdi. Det bemærkes at en \code{Node} har både en \code{Action} (som er den \code{Action} der blev taget for at komme \code{Node}n) og et \code{State}, som skal bruges til at udregne den samlede cost (\code{PathCost}). 

\subsection{Setup og kørsel af programmet}
Kørsel af en rutefinding foregår ved først at parse en tekstfil til en knowledge base. Den KB, sammen med et \code{StartState} og \code{EndState} gives som parametre til \code{AStar.Search()}, som returnerer et \code{SearchResult}. \code{SearchResult} indeholder den funde mål \code{Node}, hvis der findes en sti. Denne \code{Node} er første element i en linked list af \code{Node}s som fører til start knuden der blev søgt fra. På den måde kan hele ruten printes/analyseres. 

Vi har udvidet vores program med kode til at tegne en givnen rutefindings KB og den fundne rute mellem to knuder. På figur (\ref{scr:copenhagen}) ses hvordan programmet visualiserer en rute gennem København KB'en.


\begin{figure}
  \centering
  \includegraphics{copenhagen.png}
  \label{scr:copenhagen}
  \caption{Ruten (markeret med grønt) fra start (blå) til slut (rød) knuden. Det bemærkes at de fleste vejee er ensrettede og ruten derfor ikke tager den umiddelbart intuitive form}
\end{figure}


\section{Inferens} 
\subsection{Repræsentation af data / Datastrukturer}
\subsection{Resolution}
\subsection{Heuristik}
\subsection{Setup og kørsel af programmet}


\section*{Konklusion} 
\subsection{Output?}
\subsection{Status på engine}
Fejler uden heurestik på PQ-inferens.
Mangler at implementere at én resolve kan give flere Nodes.
Tager flere iterationer med H(n) på KBH-rutefinding

\section*{Datastrukturer}
Klausuler som struct med Navn + Proposition
Vi burde bruge HashSet (virker ikke?!)
KB er en liste af klausuler
State har klausuler
Node har state
Prioritetskø som frontier (burde bruge minhob til køen)

\section*{Kørsel af programmet}
Parser .kb filer til en KB
Search tager kb og Target state (tom klausul for inference, state for routefinding)




\end{document}