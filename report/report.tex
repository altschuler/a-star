\documentclass[danish]{article}

\usepackage{fullpage} 
\usepackage[latin1]{inputenc} 
\usepackage[danish]{babel}
\usepackage{listings} 
\usepackage{xcolor}
\usepackage{amssymb} 
\usepackage{amsmath} 
\usepackage{fancyhdr}
\usepackage{lastpage} 
\usepackage{hyperref}
\usepackage{parskip} 
\usepackage{graphicx} 
\usepackage{epstopdf}
\usepackage{abstract}
\usepackage{url}


% setup c sharp syntax highlight 
\lstdefinestyle{sharpc}{ language=[Sharp]C,
frame=lr, rulecolor=\color{black}, basicstyle=\footnotesize\ttfamily,
keywordstyle=\bfseries\color{green!40!black},
commentstyle=\itshape\color{purple!40!black}, identifierstyle=\color{blue},
stringstyle=\color{orange}}

\lstset{ style=sharpc, numbers=left, escapeinside={\<*}{*>},
breakatwhitespace=true }

% code formatting helper 
\newcommand{\code}[1]{\texttt{#1}}

% no paragraph indention 
\setlength{\parindent}{0pt}

% setup page style 
\pagestyle{fancy} 
\fancyhf{} 
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt} 
\lfoot{Side \thepage{} af \pageref{LastPage}}
\rfoot{07/05-2013} \lhead{02180 Intro to A.I.} 
\chead{Heureka} 
\rhead{}

\author{
  Patrick Gadd\\
  \texttt{s113491}
  \and
  Simon Altschuler\\
  \texttt{s123563}
}
\title{Heureka projekt}
\date{07/05-2013}

\begin{document}
\maketitle

\textbf{Abstract} \\ 
I denne opgave gennemgås hvordan deduktion i sætningslogik (eng: Propositional Logic) samt rutefinding kan optimeres ved at repræsentere disse som grafer.
Når denne type problemer er repræsenteret som grafer, er det muligt at anvende \code{A*}-algoritmen, med en passende heuristisk funktion, til at finde en løsning mere effektivt end ved eksempelvis Breadth-First-Search (BFS) eller Uniform-Cost-Search (UCS).
I opgaven vil teorien bag samt implementationen blive gennemgået.

\clearpage

\section{Introduktion} 

Til projektet har vi brugt \code{C\#} til implementation af programmet. 

\section{\code{A*} generelt} 
\code{A*}-algoritmen bruges generelt til at søge mere effektivt i grafer, end \code{BFS} og \code{UCS}, som den tager udgangspunkt i.
Algoritmen forudsætter dog at der er tale om informeret søgning, hvilket betyder at man fra en vilkårlig knude kan estimere hvor langt man er fra mål-knuden i søgningen, samt at der holdes styr på hvor dybt den givne knude ligger i søgetræet.

\code{BFS} prioriterer at man udforsker knuder, sådan at dybden af grenene i søgetræet maksimalt er dybden én fra hinanden.
Dette opnås ved at lægge knuderne i en \code{FIFO-kø}.

\code{UCS} bygger videre på \code{BFS}, men introducerer en cost-funktion, \code{g(n)}, som anvender vægtning af kanterne mellem knuder til at holde søgegrenenes længde uniform.
\code{g(n)} er summen af kantlængderne fra rodknuden til den nuværende.
\code{FIFO-køen} udskiftes med en prioritetskø, der netop bruger \code{g(n)} til at afgøre hvilken knude der skal udforskes som den næste.

\code{A*} er en videreudvikling af \code{UCS}, der anvender en heuristisk-funktion, \code{h(n)}, som forsøger at forudsige hvor langt der højst er til mål-knuden fra en given knude.
Ved at tage summen af \code{g(n)} og \code{h(n)} har man et optimistisk estimat for den totale længde af den korteste rute fra en knude i prioritetskøen, \code{f(n)}.
Hermed forsøger algoritmen direkte at følge den korteste rute til mål-knuden.

Når algoritmen udforsker en knude, vil det i kraft af \code{f(n)}, være den på den korteste rute til mål-knuden gennem den givne knude.
Dette medfører at når en knude én gang har været udforsket, skal andre ruter/grene af søgningen ikke efterfølgende udforske ruter hvori den indgår, da disse vil have større \code{f(n)} i sidste ende.

\subsection{Cost-funktion og Heurestik}

\subsection{Implementering af algoritmen}
\begin{lstlisting}
SearchResult Search(Node initialNode, KnowledgeBase kb)
{  frontier = new PriorityQueue<NodeAbstract>();
   explored = new List<StateAbstract>();
   end = initialNode.Target;  //The target/goal state
   frontier.Add(initialNode);
    
   while (frontier.Count > 0){
      currentNode = frontier.Pop(); // Chooses the lowest-cost node in the frontier
	  if (currentNode.State.Equals(end))
	     return new SearchResult(currentNode, statesSearched, true); //Return if goal-state is reached
		
        explored.Add(currentNode.State);
        
        var actions = kb.ActionsForNode(currentNode); //Get available actions to the State of the current Node

		foreach (var action in actions)
         {
			var child = kb.Resolve(currentNode, action, end, explored);
			if (!explored.Contains(child.State))
            {
				explored.Add(child.State);
				frontier.Add(child);
            }else{
				//Giver mening hvis man ser eksemplet i bogen s. 84.
				for (int i = 0; i < frontier.Count; i++)
				{
					var frontierNode = frontier[i];
					if (frontierNode.State.Equals(child.State) && frontierNode.PathCost > child.PathCost)
					{
						frontier[i] = child;
						break;
					}
				}
			}
        }
    }
    return new SearchResult(null, statesSearched, false);
}

\end{lstlisting}



\section{Rutefinding} 
I rutefinding har vi implementeret \code{A*} algoritmen med formålet at finde korteste vej i en vægtet graf, som repræsenterer faktiske kort over landområder. Vi har testet vores implementation med de fra undervisningen givne kort over dele af København og Manhattan.

\subsection{Repræsentation af data / Datastrukturer}
I rutefinding består et \code{State} af et \code{(X,Y)} koordinat som beskriver knudens position på kortet. Dette er alt hvad der skal bruges for at udregne den heuristiske værdi fra en arbitrær knude til en given mål-\code{State}.

En \code{Action} finder sin cost ved at udregne afstanden mellem sit \code{StartState} og \code{EndState}s koordinater.

Knowledge basen for rutefinding genereres ud fra en tekstfil med følgende struktur:

\begin{lstlisting}
startX_1 startY_1 navn_1 slutX_1 slutY_1
startX_2 startY_2 navn_2 slutX_2 slutY_2
...
startX_n startY_n navn_n slutX_n slutY_n
\end{lstlisting}

Dette bliver parset til to states (start og end) og en action i mellem dem, som alle bliver gemt i Knowledge basen. Alle \code{Action}s bliver fundet på forhånd så \code{A*} algoritmen ikke skal søge gennem \code{State}s under eksekvering, men blot kan slå de relevante \code{Action}s op. Det betyder et større pladsforbrug, men en bedre tidskompleksitet efter parsing.

Hver linie i knowledge basen repræsenterer en \emph{ensrettet} vej, hvilket vil sige at der skal to linier til at beskrive en vej på hvilken man både kan gå den ene og den anden vej.

\subsubsection{Prioritetskø}
\code{A*} algoritmen gør brug af en såkaldt prioritetskø kaldet \code{frontier} i koden. Denne er implmenteret som en liste der sorterer alle elementerne ved hver indsættelse af et nyt element. Elementerne, som er \code{Node}s, sorteres efter deres totale estimerede cost til mål ($f(n)$), således at \code{Node}n der umiddelbart er mest lovende undersøges først.

\subsection{Heuristik}
Den heuristiske værdi for en \code{Node} (\code{h(node)}) i rutefinding er bestemt ud fra fugleflugts afstanden til målet. Den strategi egner sig bedst til åbne grafer uden ``blindgyder'', da \code{h(node)} ikke kan tage højde for disse og vil forsøge at gå ned af blindgyderne hvis de ligger tættere på målet. \code{f(node)}, altså den samlede heuristiske værdi (cost indtil nu plus estimeret afstand til mål), udregnes på følgende måde for enhver knude i grafen under rutefinding:
\[ h(node) = \sqrt{(node.State.X - targetState.X)^2 + (node.State.Y - targetState.Y)^2} \]
\[ f(node) = node.Parent.PathCost + node.Action.Cost + h(node) \]
Hvor \code{node.Parent} er den \code{Node} fra hvilken algoritmen kom til den nuværende \code{Node}. \code{node.PathCost} er den samlede cost for at komme til \code{Node}n, \emph{uden} den heuristiske værdi. Det bemærkes at en \code{Node} har både en \code{Action} (som er den \code{Action} der blev taget for at komme \code{Node}n) og et \code{State}, som skal bruges til at udregne den samlede cost (\code{PathCost}). 

\subsection{Setup og kørsel af programmet}
Kørsel af en rutefinding foregår ved først at parse en tekstfil til en knowledge base. Den KB, sammen med et \code{StartState} og \code{EndState} gives som parametre til \code{AStar.Search()}, som returnerer et \code{SearchResult}. \code{SearchResult} indeholder den funde mål \code{Node}, hvis der findes en sti. Denne \code{Node} er første element i en linked list af \code{Node}s som fører til start knuden der blev søgt fra. På den måde kan hele ruten printes/analyseres. 

Vi har udvidet vores program med kode til at tegne en givnen rutefindings KB og den fundne rute mellem to knuder. På figur (\ref{scr:copenhagen}) ses hvordan programmet visualiserer en rute gennem København KB'en.

\begin{figure}
  \centering
  \includegraphics{copenhagen.png}
  \label{scr:copenhagen}
  \caption{Ruten (markeret med grønt) fra start (blå) til slut (rød) knuden. Det bemærkes at de fleste vejee er ensrettede og ruten derfor ikke tager den umiddelbart intuitive form}
\end{figure}

\section{Inferens} 
Inferens delen af koden er på de fleste områder meget lig rutefindingen. Vi har gjort koden generisk nok til at de begge benytter den samme \code{A*} implementation, og at begge slags KB implementerer et fælles interface.

Ydermere extender \code{Node}, \code{Action} og \code{State} i både inferens og rutefinding fra de abstrakte implementationer, hvilket bl.a. er det der muliggør den ensartede \code{A*} søgning.

De største forskelle ligger i udregning af den heuristiske værdi, og hvad et \code{State} består af, samt hvad målet er. 

I inferens søgning har vi et \code{StartState} som er den negerede af det vi ønsker at bevise (f.eks. $\lnot water$ hvis vi ønsker at bevise at vi har $water$), og vi går således efter den tomme klausul. Det gør vi fordi det vil betyde at det ikke er muligt \emph{ikke} at have $water$. 

\subsection{Repræsentation af data / Datastrukturer}
I inferens består et \code{State} af en liste af \code{Literal}s, kaldet en klausul. En \code{Literal} er en atomar konstant der enten er positiv eller negativ. Det kan f.eks. være $water$ som ville betyde at konstanten ``water'' er tilstede, hvorimod $\lnot water$ ville betyde at ``water'' \emph{ikke} er tilstede.

En liste af disse kalder vi som sagt klausuler, og det er disse der udgør et \code{State} i inferens søgning. KB'en er i CNF\footnote{Artificial Intelligence: A modern approach (Russel \& Norvig, 1995), s. 278} format, hvilket vil sige at den er opstillet af et antal konjunkerede klausuler bestående af literaler.

Matematisk set har KB'en formattet:
\[
(P_1 \lor P_2 ... \lor P_n) \land (Q_1 \lor Q_2 ... \lor Q_n) ...
\]
Hvor paranteserne indeholder en klausul og det hele er en KB i CNF format. Ligesom i rutefinding bliver inferens KB'erne parset ud fra en tekstfil med følgende format
\begin{lstlisting}
-literal_1 literal_2
-literal_2 literal_3
literal_4 literal_1 literal_3
\end{lstlisting}
Her betyder ``-'' negering af literalet. Hver linie i filen svarer til en klausul af disjunkerede literaler.

\subsubsection{Opstilling af en CNF KB}
Når en KB skal opstilles i CNF format skal der sædvanligvis omskrives fra udsagnslogisk format til disjunkerede klausuler. Det har vi gjort ved at benytte regler som f.eks. De Morgans lov\footnote{Artificial Intelligence: A modern approach (Russel \& Norvig, 1995), s. 193}, og generelle omskrivningsregler\footnote{AI Lore 9 side 7 samt Russel \& Norvig s. 281}. Eksempelvis følgende omskrivning fra udsagnslogik til disjunkeret literaler:
\[
vand \land sol \to liv
\equiv \lnot(vand \land sol) \lor liv
\equiv \lnot vand \lor \lnot sol \lor liv
\]

\subsection{Resolution}
TODO
Resolution af klausuler foregår ved 
\begin{lstlisting}
foreach (var literal in parent.State.Clause)
{
    foreach (var rule in action.Clause)
    {
        if (literal.Name.Equals(rule.Name) && literal.Proposition != rule.Proposition)
        {
            // Merger samtlige literals fra de to clauses
            state.Clause = parent.State.Clause.Concat(action.Clause).ToList();

            // Fjern en enkelt positiv og en enkelt negativ
            state.Clause.Remove(state.Clause.First(lit => lit.Name.Equals(rule.Name) && lit.Proposition));
            state.Clause.Remove(state.Clause.First(lit => lit.Name.Equals(rule.Name) && !lit.Proposition));

            // Fjerne duplikater, f.eks. A & A & B -> A & B
            state.Clause = state.Clause.Distinct().ToList();

            return new InferenceNode(parent, parent.Target, state, new InferenceAction(state, parent.Target));
        }
    }
}
\end{lstlisting}

\subsection{Heuristik}
Den heuristiske værdi i inferens er simpelthen lig med antallet af literaler i en klausul. Det er den fordi målet altid er den tomme klausul, da vi benytter indirekte bevis.

\subsection{Setup og kørsel af programmet}
Kørsel af en inferens søgning foregår på næsten identisk vis som i rutefinding. Der parses en tekstfil til en knowledge base og denne samt et start og mål \code{State} gives som parametre til \code{AStar.Search()} funktionen. På samme måde som rutefinding fås naturligvis også et resultat tilbage i form af et \code{SearchResult}

\section*{Konklusion} 
\subsection{Output?}
\subsection{Status på engine}
Fejler uden heurestik på PQ-inferens.
Mangler at implementere at én resolve kan give flere Nodes.
Tager flere iterationer med H(n) på KBH-rutefinding

\section*{Datastrukturer}
Klausuler som struct med Navn + Proposition
Vi burde bruge HashSet (virker ikke?!)
KB er en liste af klausuler
State har klausuler
Node har state
Prioritetskø som frontier (burde bruge minhob til køen)

\section*{Kørsel af programmet}
Parser .kb filer til en KB
Search tager kb og Target state (tom klausul for inference, state for routefinding)




\end{document}